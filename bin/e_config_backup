#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from __future__ import print_function

import itertools as it, operator as op, functools as ft
from collections import namedtuple
from subprocess import Popen, PIPE
import os, sys, re

Group = namedtuple('group', 'name type key contents')
Value = namedtuple('value', 'name type contents')

def get_element_name(elm, deep=True):
	if isinstance(elm, Value) and elm.name == '"name"': return elm.contents
	elif deep:
		for sub in elm.contents:
			name = get_element_name(sub, deep=False)
			if name: return name
sort_func = lambda elm: (elm.__class__.__name__, get_element_name(elm), elm)



# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class eet_cfgScanner(runtime.Scanner):
	patterns = [
		("';'", re.compile(';')),
		("'value'", re.compile('value')),
		("r'\\}'", re.compile('\\}')),
		("r'\\{'", re.compile('\\{')),
		("'group'", re.compile('group')),
		('[ \\t\\r\\n]+', re.compile('[ \\t\\r\\n]+')),
		('END', re.compile('$')),
		('N', re.compile('[+\\-]?[\\d.]+')),
		('S', re.compile('"([^"\\\\]*(\\\\.[^"\\\\]*)*)"')),
		('VT', re.compile('\\w+:')),
		('GT', re.compile('struct|list|hash')),
		('K', re.compile('(key\\s+"[^"]*"\\s*;)?')),
	]
	def __init__(self, str,*args,**kw):
		runtime.Scanner.__init__(self,None,{'[ \\t\\r\\n]+':None,},str,*args,**kw)

class eet_cfg(runtime.Parser):
	Context = runtime.Context
	def config(self, _parent=None):
		_context = self.Context(_parent, self._scanner, 'config', [])
		block = self.block(_context)
		END = self._scan('END', context=_context)
		return block

	def block(self, _parent=None):
		_context = self.Context(_parent, self._scanner, 'block', [])
		_token = self._peek('K', "'value'", context=_context)
		if _token == 'K':
			block_group = self.block_group(_context)
			return block_group
		else: # == "'value'"
			block_value = self.block_value(_context)
			return block_value

	def block_group(self, _parent=None):
		_context = self.Context(_parent, self._scanner, 'block_group', [])
		K = self._scan('K', context=_context)
		self._scan("'group'", context=_context)
		S = self._scan('S', context=_context)
		GT = self._scan('GT', context=_context)
		self._scan("r'\\{'", context=_context)
		contents = list()
		while self._peek("r'\\}'", 'K', "'value'", context=_context) != "r'\\}'":
			block = self.block(_context)
			contents.append(block)
		self._scan("r'\\}'", context=_context)
		return Group(S, GT, K, contents)

	def value(self, _parent=None):
		_context = self.Context(_parent, self._scanner, 'value', [])
		_token = self._peek('S', 'N', context=_context)
		if _token == 'S':
			S = self._scan('S', context=_context)
			return S
		else: # == 'N'
			N = self._scan('N', context=_context)
			return N

	def block_value(self, _parent=None):
		_context = self.Context(_parent, self._scanner, 'block_value', [])
		self._scan("'value'", context=_context)
		S = self._scan('S', context=_context)
		VT = self._scan('VT', context=_context)
		value = self.value(_context)
		self._scan("';'", context=_context)
		return Value(S, VT, value)


def parse(rule, text):
	P = eet_cfg(eet_cfgScanner(text))
	return runtime.wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps




def dump(elm, indent=0):
	assert isinstance(elm, (Group, Value)), elm
	if hasattr(elm, 'contents'):
		if isinstance(elm.contents, bytes):
			contents = elm.contents
		else:
			contents = ''.join(
				dump(val, indent=indent+1)
				for val in sorted(elm.contents, key=sort_func) )
	eol = bol = ''
	node = [elm.__class__.__name__, elm.name]
	if isinstance(elm, Group):
		if elm.key: bol = ' '*indent*4 + elm.key + '\n'
		if elm.name.strip('"') in [
			'E_Remember', 'E_Exehist_Item', 'Comp_Match', 'E_Config_Randr',
			'E_Config_Randr2', 'Systray_Config', 'E_Exe_List', 'History',
			'E_Config_Desktop_Background' ]: return ''
		contents = '{{\n{}{}}}'.format(contents, ' '*indent*4)
	elif isinstance(elm, Value):
		if elm.name == '"file"'\
				and elm.type == 'string:'\
				and contents.startswith('"/tmp/.lqr_wpset_bg.'):
			contents = '"/tmp/bg.png"'
		eol = ';'
	node.extend([elm.type, contents])
	return bol + ' '*indent*4 + ' '.join(node) + eol + '\n'

def dump_config(path, name=False):
	if name is True: path_home = os.path.expanduser('~/')
	try:
		if name:
			if name is True:
				name = path
				if name.startswith(path_home):
					name = '~/' + name[len(path_home):]
				name = 'file: {}'.format(name)
			data = '----- {}\n'.format(name)
		else: data = ''
		src = Popen(['eet', '-d', path, 'config'], stdout=PIPE)
		data += dump(parse('config', src.stdout.read()))
		if src.wait(): raise RuntimeError('eet exited with non-zero status')
		return data
	except Exception as err:
		print('Failed to process file: {}'.format(path), file=sys.stderr)
		raise


def main(argv=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Tool to decode E config, replace transient values (like desktop bg'
				' or E_Remember settings) and sort groups/values there to make it diff-friendly.'
			' With a second argument, also backup decoded config to a specified location.')
	parser.add_argument('config',
		help='Path to eet-encoded/compressed E config.'
			' If "-" (dash) is passed instead, list of paths to such configs will be read from stdin.')
	parser.add_argument('backup', nargs='?',
		help='Backup decoded config to the specified path.'
			' Checks file at the destination path for irrelevant changes'
				' (e.g. +/- 100 in prop.h or prop.pos_h) and skips the backup'
				' if only such diffs are detected.')
	optz = parser.parse_args(argv if argv is not None else sys.argv[1:])

	if optz.config != '-': src_data = dump_config(optz.config)
	else:
		paths = sys.stdin.read()
		sep = '\0' if '\0' in paths else '\n'
		paths = sorted(filter(None, paths.split(sep)))
		src_data = ''.join(map(ft.partial(dump_config, name=True), paths))

	if not optz.backup: sys.stdout.write(src_data)
	else:
		if os.path.exists(optz.backup):
			# Check if changes are irrelevant and can be discarded
			from tempfile import NamedTemporaryFile
			bak_data = open(optz.backup).read()

			with NamedTemporaryFile() as tmp1, NamedTemporaryFile() as tmp2:
				tmp1.write(src_data), tmp2.write(bak_data)
				tmp1.flush(), tmp2.flush()
				diff = Popen(['diff', '--unchanged-line-format=', tmp1.name, tmp2.name], stdout=PIPE)
				diff_data = diff.stdout.read()
				diff.wait()

			for line in it.imap(op.methodcaller('strip'), diff_data.splitlines()):
				# 'value "prop.pos_h" int: 291;' <-- numbers often change
				if not re.search(
					r'^value\s+"(geom|prop)\.((pos|res|size)_)?'
					r'[whxy]|startup_id"\s+int:\s+\d+\s*;$', line ): break
			else: src_data = None

		if src_data: open(optz.backup, 'w').write(src_data)

if __name__ == '__main__': main()

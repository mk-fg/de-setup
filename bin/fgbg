#!/usr/bin/env python

import ctypes as ct, itertools as it, pathlib as pl
import os, sys, re, random


class adict(dict):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self.__dict__ = self

def dpy_info():
	# Simplified randr module from https://github.com/rr-/screeninfo/
	def make_struct(name, fields):
		fields = fields.split()
		for n, fs in enumerate(fields):
			k, t = fs.split(':', 1)
			try: fields[n] = k, getattr(ct, t := f'c_{t}')
			except AttributeError:
				if not t.endswith('_p'): raise
				fields[n] = k, ct.POINTER(getattr(ct, t[:-2]))
		return type(name, (ct.Structure,), dict(_fields_=fields))

	XRRCrtcInfo = make_struct('XRRCrtcInfo', 'ts:ulong x:int y:int w:int h:int')
	XRRScreenResources = make_struct( 'XRRScreenResources',
		'ts:ulong ts_conf:ulong nctrc:int nctrcs:ulong_p nout:int out:ulong_p' )
	XRROutputInfo = make_struct( 'XRROutputInfo',
		'ts:ulong crtc:ulong name:char_p name_len:int w_mm:ulong h_mm:ulong conn:ushort' )

	xlib, xrandr = ct.CDLL('libX11.so'), ct.CDLL('libXrandr.so')
	xlib.XOpenDisplay.argtypes = [ct.c_char_p]
	xlib.XOpenDisplay.restype = ct.POINTER(ct.c_void_p)
	xrandr.XRRGetScreenResourcesCurrent.restype = ct.POINTER(XRRScreenResources)
	xrandr.XRRGetOutputInfo.restype = ct.POINTER(XRROutputInfo)
	xrandr.XRRGetCrtcInfo.restype = ct.POINTER(XRRCrtcInfo)

	dpy = xlib.XOpenDisplay(b'')
	if not dpy: raise RuntimeError('XOpenDisplay failed')
	try:
		root_win = xlib.XDefaultRootWindow(dpy)
		res = xrandr.XRRGetScreenResourcesCurrent(dpy, root_win)
		for n in range(res.contents.nout):
			out = ( out_raw := xrandr
				.XRRGetOutputInfo(dpy, res, res.contents.out[n]) ).contents
			if out.conn != 0: continue # RR_Connected=0
			if not out.crtc: continue
			try:
				crtc = (crtc_raw := xrandr
					.XRRGetCrtcInfo(dpy, ct.byref(out_raw), out.crtc)).contents
				try:
					yield adict(
						x=crtc.x, y=crtc.y, w=crtc.w, h=crtc.h,
						w_mm=out.w_mm, h_mm=out.h_mm,
						name=out.name.decode(sys.getfilesystemencoding()) )
				finally: xrandr.XRRFreeCrtcInfo(crtc_raw)
			finally: xrandr.XRRFreeOutputInfo(out_raw)
	finally: xlib.XCloseDisplay(dpy)
dpy_info = lambda *,_f=dpy_info: list(_f())


def set_bg_image(p_list, mon=0, dx=None, dy=None):
	class sd_bus(ct.Structure): pass
	class sd_bus_error(ct.Structure):
		_fields_ = [ ('name', ct.c_char_p),
			('message', ct.c_char_p), ('need_free', ct.c_int) ]
	class sd_bus_msg(ct.Structure): pass
	lib = ct.CDLL('libsystemd.so')

	def run(call, *args, sig=None, check=True):
		func = getattr(lib, call)
		if sig: func.argtypes = sig
		res = func(*args)
		if check and res < 0: raise OSError(-res, os.strerror(-res))
		return res

	bus = ct.POINTER(sd_bus)()
	run( 'sd_bus_open_user', ct.byref(bus),
		sig=[ct.POINTER(ct.POINTER(sd_bus))] )

	error = sd_bus_error()
	reply = ct.POINTER(sd_bus_msg)()
	try:
		if isinstance(mon, int): mon = [mon]
		if isinstance(dx, int): dx = [dx]
		if isinstance(dy, int): dy = [dy]

		if not dx or not dy:
			run( 'sd_bus_call_method',
				bus,
				b'org.enlightenment.wm.service',
				b'/org/enlightenment/wm/RemoteObject',
				b'org.enlightenment.wm.Desktop',
				b'GetVirtualCount',
				ct.byref(error),
				ct.byref(reply),
				b'',
				sig=[
					ct.POINTER(sd_bus),
					ct.c_char_p, ct.c_char_p, ct.c_char_p, ct.c_char_p,
					ct.POINTER(sd_bus_error),
					ct.POINTER(ct.POINTER(sd_bus_msg)),
					ct.c_char_p ] )
			dxc, dyc = ct.c_int(), ct.c_int()
			run( 'sd_bus_message_read', reply, b'ii', ct.byref(dxc), ct.byref(dyc),
				sig=[ ct.POINTER(sd_bus_msg),
					ct.c_char_p, ct.POINTER(ct.c_int), ct.POINTER(ct.c_int) ] )
			if not dx: dx = list(range(dxc.value))
			if not dy: dy = list(range(dyc.value))

		mxy = list(it.product(mon, dx, dy))
		mxy_paths = list(p_list)
		while len(mxy_paths) < len(mxy):
			mxy_paths.append(random.choice(p_list))
		mxy_paths.sort(key=lambda x,_f=random.random: _f())

		for (m, x, y), p in zip(mxy, mxy_paths):
			run( 'sd_bus_call_method',
				bus,
				b'org.enlightenment.wm.service',
				b'/org/enlightenment/wm/RemoteObject',
				b'org.enlightenment.wm.Desktop.Background',
				b'Add',
				ct.byref(error),
				ct.byref(reply),
				b'iiis', m, x, y, str(p).encode(),
				sig=[
					ct.POINTER(sd_bus),
					ct.c_char_p, ct.c_char_p, ct.c_char_p, ct.c_char_p,
					ct.POINTER(sd_bus_error),
					ct.POINTER(ct.POINTER(sd_bus_msg)),
					ct.c_char_p, ct.c_int, ct.c_int, ct.c_int, ct.c_char_p ] )

	finally: run('sd_bus_flush_close_unref', bus, check=False)


def main(args=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Set E desktop background via DBus API.' )
	parser.add_argument('path',
		help='Background image path.'
			' If path is a directory, images get matches by'
				' bmp/png/jpe?g/webp extension (case-insensitive)'
				' and get picked at random (with no repeats if possible).')
	parser.add_argument('-m', '--monitor',
		action='append', type=int, metavar='n',
		help='Physical monitor offset number to set'
			' bg on (default: all). Can be specified multiple times.')
	parser.add_argument('-x', '--desktop-x',
		action='append', type=int, metavar='n',
		help='Desktop X offset to set bg on. Can be specified multiple times.'
			' If not specified, all X values will be used (default).')
	parser.add_argument('-y', '--desktop-y',
		action='append', type=int, metavar='n',
		help='Desktop Y offset to set bg on. Can be specified multiple times.'
			' If not specified, all Y values will be used (default).')
	# XXX: can add some image manipulation here, based on dpy_info
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	p = pl.Path(opts.path)
	if p.is_dir():
		p_list = list()
		for root, dirs, files in os.walk(p, followlinks=True):
			for name in files:
				if not re.search(r'(?i)\.(bmp|png|jpe?g|webp)$', name): continue
				p_list.append(pl.Path(root) / name)
	else: p_list = [p]
	if not p_list: parser.error(f'No images matched for path: {p}')

	mon_list, dx, dy = opts.monitor, opts.desktop_x, opts.desktop_y
	if not mon_list:
		mon_list = dpy_info()
		mon_list = list(range(len(mon_list)))

	set_bg_image(p_list, mon_list, dx, dy)

if __name__ == '__main__': sys.exit(main())
